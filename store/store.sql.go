// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: store.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"
)

const cleanupOldEvents = `-- name: CleanupOldEvents :exec
WITH rows_to_delete AS (
    SELECT tenant_id
    FROM processed_events
    WHERE occurred_at < NOW() - INTERVAL '1 hour' * $1
    LIMIT 10000
    )
DELETE FROM processed_events
    USING rows_to_delete
WHERE processed_events.ctid = rows_to_delete.ctid
`

func (q *Queries) CleanupOldEvents(ctx context.Context, dollar_1 interface{}) error {
	_, err := q.db.ExecContext(ctx, cleanupOldEvents, dollar_1)
	return err
}

const isDuplicate = `-- name: IsDuplicate :one
SELECT EXISTS (
    SELECT 1 FROM processed_events
    WHERE tenant_id = $1
      AND event_type = $2
      AND rule_id = $3
      AND event_sha = $4
      AND actual_event_persistentce_time >= NOW() - INTERVAL '1 hour' * $5
      LIMIT 1
)
`

type IsDuplicateParams struct {
	TenantID  string      `json:"tenant_id"`
	EventType string      `json:"event_type"`
	RuleID    string      `json:"rule_id"`
	EventSha  string      `json:"event_sha"`
	Column5   interface{} `json:"column_5"`
}

func (q *Queries) IsDuplicate(ctx context.Context, arg IsDuplicateParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isDuplicate,
		arg.TenantID,
		arg.EventType,
		arg.RuleID,
		arg.EventSha,
		arg.Column5,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const saveEvent = `-- name: SaveEvent :exec
INSERT INTO processed_events (tenant_id, event_type,rule_id, event_sha, event_details, occurred_at, actual_event_persistentce_time)
VALUES ($1, $2, $3, $4, $5::json, $6,NOW())
    ON CONFLICT (tenant_id, event_type, rule_id,event_sha) DO NOTHING
`

type SaveEventParams struct {
	TenantID   string          `json:"tenant_id"`
	EventType  string          `json:"event_type"`
	RuleID     string          `json:"rule_id"`
	EventSha   string          `json:"event_sha"`
	Column5    json.RawMessage `json:"column_5"`
	OccurredAt sql.NullTime    `json:"occurred_at"`
}

func (q *Queries) SaveEvent(ctx context.Context, arg SaveEventParams) error {
	_, err := q.db.ExecContext(ctx, saveEvent,
		arg.TenantID,
		arg.EventType,
		arg.RuleID,
		arg.EventSha,
		arg.Column5,
		arg.OccurredAt,
	)
	return err
}
